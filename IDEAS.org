* Discrete Event Simulation --- A unifying abstraction?

  Thinking of games as a simulation with discrete objects and events
  may be a useful unifying abstraction.

  World = Set(Object)

  The World maintains this set; a mapping between ObjectIds and
  Objects; and a 2D mesh of where Objects are located. (Objects
  themselves do not know their location.)

  --

  Object = ObjectId x BoundingShape x State

  Every object has an identifier; a bounding shape (static); and an
  internal state. (They do not keep track of where they are.)

  Object->draw : Object -> Maybe(Rendering)

  Objects can be drawn, but may choose not to be.

  Object->react : Object Set(Event) -> Set(EventCreationCommand)

  Objects support a react method that receives a set of input events
  and returns a set of output event creation commands.

  --

  EventCreationCommand = Offset x Event

  Specifies an event to be created at a given offset from the
  originating object.

  Event = BoundingShape x ?

  Events are only visible to things within their BoundingShape, but
  other than that they are abstract; a few examples are given
  below. (Like objects, they do not keep track of where they are.)

  A bounding shape/position doesn't make sense for all events. For
  example, does an object creation event have a bounding shape?

  It may make sense to keep distinct events that are inputs and events
  that are outputs. Some examples Events...

  (input) TickEvent = FrameNumber

  Time has ticked forward and it is now some specific time.

  (input) InputEvent = ...

  The player has produced some input. Perhaps tagged to a specific
  player.

  (output) SoundEvent = ...

  A certain sound should be produced

  (output) ObjectCreationEvent = Object

  Create a new object at the location

  (output) MovementEvent = Offset

  Move the generating object by a certain amount.

  Problem: An offset doesn't specify the path the object went on, so
  intermediate collision are not detected and movement can be jerky
  (slash) can't be smoothed.

  (input) CollisionEvent = Object x Object

  Two objects have collided (or leave off the first and leave implicit
  that the receiving object has collided.)

  (output) ObjectDestructionEvent = ()

  The object should be removed

  --

  The world loop would then be responsible for (a) propagating events
  to those that can receive them and (b) detecting collisions and
  generating the corresponding events.

  A number of different event flows are possible:

  (a) The same set of input events are visible to all objects (modulo
  proximity) and all output events are evaluated simultaneously.

  Pros: Fairly functional
  Cons: Objects passing through each as (0,0) goes to (1,1) and (1,1)
  goes to (0,0); using events to communicate inside the simulation
  introduces a minimum of a frame's delay.

  (b) Objects are visited in some order and their output events are
  evaluated immediately... potentially affecting the input events of
  other objects. 

  Pros: Some times allows the detection of incremental movement
  collisions; potentially faster as it will use less memory
  Cons: Non-functional and difficult to reason about.

  (c) The fixed point of object reactions is computed and all output
  events are evaluated simultaneously.

  Pros: Allows clean communication between objects within one frame by
  generating events that are later observed.
  Cons: Computationally expensive.

  --

  Using objects/events to communicate but delaying by a frame may have
  very painful implications for players. For example, we could imagine
  having a input event trigger the player's avatar to generate
  movement event. If this event is not evaluated until the end of the
  frame than it means the player cannot react to something they saw
  /last/ frame and immediately reacted to.

  Frame  n-2: _P_.
  After  n-2: (bullet causes movement)
  Frame  n-1: _P._
  After  n-2: (bullet causes movement)
  Before   n: (player presses left)
  Frame    n: _%__ (P and . are super-imposed)
  After    n: (bullet causes movement)
  After  n+1: (player causes movement)
  Early  n+1: (collision is detected)
  During n+1: (p is killed, bullet is destroyed)
  Frame  n+1: _X__ (P is dead)

  As opposed to

  Frame  n-2: _P_.
  After  n-2: (bullet causes movement)
  Frame  n-1: _P._
  After  n-2: (bullet causes movement)
  Before   n: (player presses left)
  During   n: (player causes movement)
  Frame    n: P.__ 
  After    n: (bullet causes movement)

  I think this sort of test needs to be worked out.

  --

  The world itself can follow the same protocol, which lends nicely to
  embedded worlds and clean code.

  --

  By removing the ability of objects to know their location and to
  only communicate their changing location by offsets, it allows the
  world to use a better data-structure for the 2d mesh. For example,
  it could use a mutable matrix and update it when it evaluates
  events.

  --

  I wonder if it would be good for certain kinds of events to be
  restricted... like objects can't produce tick or input events?
  Producing input events may be an elegant way to represent AIs.

  --

  Rather than using custom events, it may make sense to insist that
  inter-object communication events be reified as objects that can
  collide with the objects that receive them, but may not see them.
