* DONE Move tests into test submodules
  CLOSED: [2012-05-25 Fri 01:23]
* DONE Write a makefile that runs all the tests with raco test
  CLOSED: [2012-05-25 Fri 01:29]
* DONE Really implement openal on linux
  CLOSED: [2012-06-19 Tue 19:46]
* DONE Really implement joysticks on linux
  CLOSED: [2012-06-24 Sun 08:34]
* DONE Remove controller debugging printfs
  CLOSED: [2012-06-25 Mon 17:30]
* DONE Reorganize exp directory into other directories
  CLOSED: [2012-06-25 Mon 19:38]
* DONE Change gl model to keep track of sizes for centering, etc
  CLOSED: [2012-06-26 Tue 19:15]
* DONE Make dashboard
  CLOSED: [2012-06-29 Fri 22:25]
* DONE Add scoring back into tennis/OS
  CLOSED: [2012-06-30 Sat 22:25]
* DONE Correct tennis angle of reflection
  CLOSED: [2012-06-30 Sat 19:52]
* DONE Separate OS out of tennis/OS
  CLOSED: [2012-07-03 Tue 20:47]
* DONE Improve tennis/OS structure
  CLOSED: [2012-07-04 Wed 22:39]
* DONE Make tennis harder over time: more balls, faster movement, larger opponent
  CLOSED: [2012-07-04 Wed 22:39]
* DONE I can still get stuck on the wall and the paddle sometimes in Tennis
  CLOSED: [2012-07-04 Wed 22:39]
* DONE Rewrite maze with OS model
  CLOSED: [2012-07-08 Sun 00:32]
* DONE Improve maze OS structure
  CLOSED: [2012-07-18 Wed 18:40]
* DONE OS - fix connection to 3s
  CLOSED: [2012-07-21 Sat 13:06]
  There is a use in tennis that would be fixed

  And maze uses it for the background music
* DONE Figure out how to use OpenGL depth bit for background/foreground
  CLOSED: [2012-08-04 Sat 14:05]
  A lot of people online seem to suggest it is bad to use the Z buffer
  because of transparency issues. Strange.

  Now use it
* DONE Maybe change graphics to fixed pixels?
  CLOSED: [2012-08-05 Sun 19:45]
  Render to a buffer and then display the buffer?
  ---
  Take the SNES w x h and make it wider, see exp/wide.rkt
  ---
  Maybe use bsnes's snesshaders to do the scaling?

  http://filthypants.blogspot.com/2011/05/more-emulator-pixel-shaders-crt-updated.html

  http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html
  ---
  Hopefully this will make planning and text better
  --
  I'm using exp/buffer.rkt to experiment and it is MESSED up.
* DONE maze - use CRT size directly?
  CLOSED: [2012-08-06 Mon 15:01]
  In this case, I'm not sure it is a good idea, because we already use
  a 16:9 frame and it is convenient to imaging that the 1x1 boxes in
  the maze are the real thing and the 16x9 pixels are just the display
* DONE maze - sometimes the white ghost disappears... it's weird
  CLOSED: [2012-08-06 Mon 19:10]
  It was a problem with depth. Annoying. I'll have to revisit depth
  later.
* DONE tennis - use CRT size directly?
  CLOSED: [2012-08-06 Mon 19:49]
* DONE Change controller model
  CLOSED: [2012-08-09 Thu 15:58]
  SNES style
  D-pad is booleans
  Have another right interpretation of dpad

  Get a USB snes controller for home
* DONE Switch to RacketGL throughout
  CLOSED: [2012-08-09 Thu 16:28]
* TODO Switch to a fully shader based rendering system
  I have begun experimenting with this a lot.
  
  --Why--
  
  [[http://www.opengl.org/wiki/FAQ#Are_glTranslate.2FglRotate.2FglScale_hardware_accelerated.3F][This FAQ]] says that OpenGL doesn't accelerate the fixed-function
  pipeline any longer. [[http://gamedev.stackexchange.com/questions/25411/basics-of-drawing-in-2d-with-opengl-3-shaders][This StackOverflow question]] suggests a general
  structure. ([[http://stackoverflow.com/questions/1556535/using-opengl-to-accelerate-2d-graphics?rq%3D1][This one]] also talks about the same stuff.)
  
  --Plan--
  
  My original plan was to have a single vector input to the shader
  that was something like:
  
  Translation: XY
  Scale:       XY    (relative to the sprite, not the scene)
  Rotation:    Theta (relative to the sprite, not the scene)
  Color:       RGBA
  Rectangle:   WH
  Texture:     XYWH
  
  where the vertex shader would move the basis of the vertex, which is
  0,0 to the translated point, where it would then be scaled and
  rotated.
  
  the geometry shader would take this input and output the various
  vertexes for a rectangle ([[http://openglbook.com/the-book/chapter-2-vertices-and-shapes/][this site]] talks about you need 6 for
  GL_TRIANGLES but only 5 for GL_TRIANGLE_STRIP, but I don't know if
  you can do that in a geometry shader)
  
  the fragment shader would take the texture coordinates and grab the
  pixels, blending in the color. For most sprites, I would set the
  color to blank-ness and for opaque boxes, I would set the texture
  coordinates to a blank place.
  
  I hope this will allow me to have a single draw call.
  
  -- Populating it --
  
  My plan is to populate this vector by first, sorting the sprites
  into their layers with the background towards the front of the
  array. (My assumption is that background layers change less so it
  will make the vector more stable.) The game would return, basically,
  a list of rows of this vector and the engine would map through
  them. However, it would keep track of what the previous lists were
  and if they were eq? and in the same order, then they would not be
  set! to decrease memory traffic.
  
  I would assume that most translations, scaling, or rotations are not
  stacked, so it is safe to compose them on the CPU.
  
  -- Texture Atlas ---
  
  Additionally, I would have a single texture for all sprites in the
  game that was always available. This is called a [[https://en.wikipedia.org/wiki/Texture_atlas][Texture atlas]]. My
  idea is to write a library that scans the directory Get Bonus is in
  for all PNGs and stitches them together in a lossless way, doing
  something basic for limiting the area, with the opportunity for
  optimization later. This library would run at the start of every
  startup and find the list of files and their checksums and see if
  the cached PNG is still up to date. Similarly, this same program
  would create PNGs for fonts.
  
  I'm imaging an interface like
  
  texture-coords : path -> coordinates
  
  where the path would be relative to the Get Bonus directory and then
  the coordinates would be in the atlas that was constructed.
  
  I'd write a tool that would rip sprite sheets apart into their
  pieces.
  
  -- Notes --
  
  I've decided to go with Cg rather than GLSL directly, because of its
  separate compiler, seems to have good optimization technology, etc.
  
  Most of Nvidia's materials seem to be very good (particularly the
  manuals and examples that come with the toolkit.) [[http://filthypants.blogspot.com/2011/06/cg-shader-tutorial-for-emulators.html][Here's another]]
  source for tutorials.
  
  My current development machine is limited to OpenGL 3.2, which is
  relevant to developing with Cg. I've written a basic FFI for Cg with
  just what I need. It would be nice if there were spec files like
  RacketGL uses for OpenGL.
  
  -- Problems --
  
  First, my idea for the layout will be complicates because
  glVertexAttribPointer function can only give vertexes with 1 through
  4 elements, not this many. I might able to do it as one big thing
  anyways, by using strides and multiple attributes. (I could even do
  a different attribute for each piece.)
  
  Second, I don't totally understand the capabilities of geometry
  shaders. Essentially what I'm doing is telling OpenGL that there is
  only 1 "vertex" but then I'm expanding it into 6 by the geometry
  shader. (In the call to glDrawArray, will I put in the number of
  objects, or the number of objects times 6? Probably just the
  number?) [[http://www.opengl.org/wiki/Tutorial4:_Using_Indices_and_Geometry_Shaders_(C_/SDL)][This tutorial]] might be a good place to start. (Also, there
  are a few examples in the Nvidia CG toolkit.)
  
  Third, my initial attempts at following [[http://openglbook.com/the-book/chapter-2-vertices-and-shapes/][this tutorial]] to get things
  up in running (exp/pipe.rkt) has failed with my three rectangle
  example. First, rectangles don't show up at all. Instead, a triangle
  does. There's also a problem that only one triangle does---the front
  most one. Second, they aren't appearing in the place that I expect
  them to. I think [[http://www.opengl.org/wiki/FAQ#How_to_render_in_pixel_space][this FAQ question]] is a piece of the answer. I think
  I should start from scratch and adapt his example directly (to
  compare the drawings, for example) and go from there. ([[http://www.songho.ca/opengl/gl_vertexarray.html][This is
  another tutorial]] that may be useful.)
  
  I'm not totally certain about what the right thing to do with the
  blending between alpha, the color, and the texture color. [[http://www.opengl.org/discussion_boards/showthread.php/166520-Alpha-blending-with-Cg-shaders][Here's a
  thread]] that might have information. I also think I need to use
  (glShadeModel GL_FLAT) so that the color isn't interpolated.
  
  This is a very frustrating thing to be doing. I feel like a 142
  student.
  
  -- Useful paths --
  
  CG documentation --- /usr/share/doc/nvidia-cg-toolkit
  CG examples --- /usr/lib/nvidia-cg-toolkit/examples/OpenGL
  
  I had to install nvidia-cg-toolkit from Nvidia directly
  (Cg-3.1_April2012_x86_64.deb) because the Ubuntu one was broken.

  -- Further investigation --

  I transliterated the code from the tutorial into Racket precisely,
  including using GLUT and everything. However, it is black. I
  originally assumed this was because of GLEW, but when I disable GLEW
  in the C code, it works, but not in my code. Mysterious.

  I used 'apitrace' to determine that the OpenGL calls the two
  programs were making were literally IDENTICAL. Still, they display
  differently. My current guess is that the vertex arrays are being
  populated differently.

  After doing some tracing on the C side, I see that the bytes in my
  vertex arrays are different than the ones on the C side. Yet, I'm
  using f32vectors, which are supposed to be _float arrays. Weird.

  ARRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHH

  I mixed up the sign on a vector coordinate. The byte difference was
  just an error in printing on the C side.

  Alright, now that I have a working program, I have to go back to
  being in racket/gui or accept my new GLUT overlord. Or maybe GLFW?
* TODO GLFW - Add support for getting the string identifiers of joysticks
* TODO Investigate and potentially use DDS for textures
  https://en.wikipedia.org/wiki/DirectDraw_Surface
* TODO Try to get OpenGL to do collision detection for me
  http://kometbomb.net/2008/07/23/collision-detection-with-occlusion-queries-redux/
* TODO See if I can record a video directly
  http://revel.sourceforge.net/docs/html/revel_8h.html#a30
* TODO Make XML shader reading more robust
  In case there is just a fragment, vertex, etc (see bsnes examples)
* TODO Allow multi-pass shaders (such as CRT halation)
  See libretro or retroarch

  And maybe use Cg rather than GLSL
* TODO Make fixed-size fonts better
* TODO Use SNES sprites for Ms. Pac-Man in maze
* TODO tennis - balls can bounce infinitely off wall and get stuck
* TODO Make it so gl:Color doesn't have an alpha arg
  Because by using Z buffer for layers, translucent pixels don't work
  across layers... so maybe it is better to just disallow it?
* TODO Make a faster FPS counter
  Making a texture is slow. Maybe with character-based string textures
  it would be faster?
  
  Maybe just log data and look at it afterward?
  
  I don't know if I really am measuring this correctly... see OpenGL wiki
* TODO OS suppress updates
  Make a critical region system call that gives a process sole access
  to the system... leaving the other processes stalled with their last
  writes persisting from frame to frame
  
  This might be a good way to implement "friction" or "bullet time" as
  well as other effects, like menus.
  
  Just an idea. Might be a bad idea?
* TODO Make maze harder over time: faster, more ghosts, squares = score multiplier
* TODO tennis - shake the screen on bounce, gas pedal on paddle for speed, decreasing increasing rate of ball speed growth, add blocks like arkanoid?
* TODO tennis - score based on total number of balls in play
* TODO Change gl model to be memoized
* TODO Make games return score information to dashboard for it to manager
  (Version, Level, Numeric Score) from game

  (Game, Date, Version, Level, Numeric Score) from dashboard

  Store (cached) locally and online

  Store a cached global ranking
* TODO Make games return replays (and allow them to accept replays)
  Replay = (random seed, level, controller stream)
* TODO Build music libraries based on emotion (fast, race, scary, triump, etc)
* TODO Add "compare with ..." to game info
* TODO Make Anki-like SRS system in dashboard
* TODO Make icons for dashboards vs text
* TODO Make games in dashboard have capabilities
  1P, 2P Round-robin, 2P VS, 2P Co-op, etc
* TODO Make play modes in dashboard
  Single, King-of-the-Hill (play levels that your score has been
  beaten on), Training (improve your score, SRS style), Round-Robin
  (play all games)

  Have it so you can highlight games to be played that way
* TODO Death scream like Ziggurat (in dashboard?)
  Or other stingers, but worry about being too annoying and not
  instant restarting
* TODO Find a unified common score display
  Should I display all points: this session / this game / all games?
* TODO Return achievements (to dashboard)
* TODO Make the 'Home' button in games bring up a dashboard menu (to quit the game, give a ranking, etc)
* TODO Make audio loading lazy (or other things that are slow on boot)
* TODO Read about and implement juiciness
  http://indiegames.com/2012/05/juice_it_or_lose_it_-_a_talk_b.html
  
  https://github.com/grapefrukt/juicy-breakout
* TODO Tennis - ugly score display
* TODO Tennis - revisit use of paddle bounce
* TODO Make RPS more JRPG-like
* TODO Convert things to typed racket as I go
* TODO Write a generic Godel-encoding library
* TODO Figure out a way to do localization well
* TODO Make more games
* TODO Make something for Racket/emacs to find out what deps aren't needed
* TODO Experiment with located events (in a 2D mesh) rather than flat events
* TODO Make OS use futures for parallelism
  First experiment, 2012/07/01 failed... got a slower frame rate. I
  think the key is to make it just a future during the time that GL is
  rendering.
* TODO 2D Lighting
  https://www.youtube.com/watch?v=fsbECSpwtig
* TODO Add challenges/achievements/training to NES/SNES games
  Hook up with an emulator core to drop into a game with save states
  and then monitor its execution for score, etc

  Can you beat this Mega Man stage with one life?

  How fast can you do X in this game?

  Wrap this in a package that switches from game to game like I
  want... it may be perfection

* TODO Implement Boxing iPhone game
  Like Punch-Out!!!
  
  Five "buttons": punch left/right, dodge left/right, block. The
  upper quadrants for punching, the bottom for dodging, and the
  middle for blocking.
  
  Randomly generate winning sequences of input, then from them
  determine what the bad guy does... for example if to win you dodge
  left, then he should punch right.
  
  After going through this sequence, it just repeats.
  
  Manually design 10 or so cues that indicate an upcoming action
  (like twitching eye brows, shaking, hand/leg shuffle, etc)
  
  Aim for completing a match in 1 to 2 minutes
  
  Shake the phone to get up
* TODO Winners Don't Do Drugs and other intro screens
