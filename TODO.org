* DONE Move tests into test submodules
  CLOSED: [2012-05-25 Fri 01:23]
* DONE Write a makefile that runs all the tests with raco test
  CLOSED: [2012-05-25 Fri 01:29]
* DONE Really implement openal on linux
  CLOSED: [2012-06-19 Tue 19:46]
* DONE Really implement joysticks on linux
  CLOSED: [2012-06-24 Sun 08:34]
* DONE Remove controller debugging printfs
  CLOSED: [2012-06-25 Mon 17:30]
* DONE Reorganize exp directory into other directories
  CLOSED: [2012-06-25 Mon 19:38]
* DONE Change gl model to keep track of sizes for centering, etc
  CLOSED: [2012-06-26 Tue 19:15]
* DONE Make dashboard
  CLOSED: [2012-06-29 Fri 22:25]
* DONE Add scoring back into tennis/OS
  CLOSED: [2012-06-30 Sat 22:25]
* DONE Correct tennis angle of reflection
  CLOSED: [2012-06-30 Sat 19:52]
* DONE Separate OS out of tennis/OS
  CLOSED: [2012-07-03 Tue 20:47]
* DONE Improve tennis/OS structure
  CLOSED: [2012-07-04 Wed 22:39]
* DONE Make tennis harder over time: more balls, faster movement, larger opponent
  CLOSED: [2012-07-04 Wed 22:39]
* DONE I can still get stuck on the wall and the paddle sometimes in Tennis
  CLOSED: [2012-07-04 Wed 22:39]
* DONE Rewrite maze with OS model
  CLOSED: [2012-07-08 Sun 00:32]
* DONE Improve maze OS structure
  CLOSED: [2012-07-18 Wed 18:40]
* DONE OS - fix connection to 3s
  CLOSED: [2012-07-21 Sat 13:06]
  There is a use in tennis that would be fixed

  And maze uses it for the background music
* DONE Figure out how to use OpenGL depth bit for background/foreground
  CLOSED: [2012-08-04 Sat 14:05]
  A lot of people online seem to suggest it is bad to use the Z buffer
  because of transparency issues. Strange.

  Now use it
* DONE Maybe change graphics to fixed pixels?
  CLOSED: [2012-08-05 Sun 19:45]
  Render to a buffer and then display the buffer?
  ---
  Take the SNES w x h and make it wider, see exp/wide.rkt
  ---
  Maybe use bsnes's snesshaders to do the scaling?

  http://filthypants.blogspot.com/2011/05/more-emulator-pixel-shaders-crt-updated.html

  http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html
  ---
  Hopefully this will make planning and text better
  --
  I'm using exp/buffer.rkt to experiment and it is MESSED up.
* DONE maze - use CRT size directly?
  CLOSED: [2012-08-06 Mon 15:01]
  In this case, I'm not sure it is a good idea, because we already use
  a 16:9 frame and it is convenient to imaging that the 1x1 boxes in
  the maze are the real thing and the 16x9 pixels are just the display
* DONE maze - sometimes the white ghost disappears... it's weird
  CLOSED: [2012-08-06 Mon 19:10]
  It was a problem with depth. Annoying. I'll have to revisit depth
  later.
* DONE tennis - use CRT size directly?
  CLOSED: [2012-08-06 Mon 19:49]
* DONE Change controller model
  CLOSED: [2012-08-09 Thu 15:58]
  SNES style
  D-pad is booleans
  Have another right interpretation of dpad

  Get a USB snes controller for home
* DONE Switch to RacketGL throughout
  CLOSED: [2012-08-09 Thu 16:28]
* DONE Make a faster FPS counter
  CLOSED: [2012-09-07 Fri 15:50]
  Making a texture is slow. Maybe with character-based string textures
  it would be faster?
  
  Maybe just log data and look at it afterward?
  
  I don't know if I really am measuring this correctly... see OpenGL wiki
* TODO Switch to a fully shader based rendering system
  I have begun experimenting with this a lot.
  
  --Why--
  
  [[http://www.opengl.org/wiki/FAQ#Are_glTranslate.2FglRotate.2FglScale_hardware_accelerated.3F][This FAQ]] says that OpenGL doesn't accelerate the fixed-function
  pipeline any longer. [[http://gamedev.stackexchange.com/questions/25411/basics-of-drawing-in-2d-with-opengl-3-shaders][This StackOverflow question]] suggests a general
  structure. ([[http://stackoverflow.com/questions/1556535/using-opengl-to-accelerate-2d-graphics?rq%3D1][This one]] also talks about the same stuff.)
  
  --Plan--
  
  My original plan was to have a single vector input to the shader
  that was something like:
  
  Translation: XY
  Scale:       XY    (relative to the sprite, not the scene)
  Rotation:    Theta (relative to the sprite, not the scene)
  Color:       RGBA
  Rectangle:   WH
  Texture:     XYWH
  
  where the vertex shader would move the basis of the vertex, which is
  0,0 to the translated point, where it would then be scaled and
  rotated.
  
  the geometry shader would take this input and output the various
  vertexes for a rectangle ([[http://openglbook.com/the-book/chapter-2-vertices-and-shapes/][this site]] talks about you need 6 for
  GL_TRIANGLES but only 5 for GL_TRIANGLE_STRIP, but I don't know if
  you can do that in a geometry shader)
  
  the fragment shader would take the texture coordinates and grab the
  pixels, blending in the color. For most sprites, I would set the
  color to blank-ness and for opaque boxes, I would set the texture
  coordinates to a blank place.
  
  I hope this will allow me to have a single draw call.
  
  -- Populating it --
  
  My plan is to populate this vector by first, sorting the sprites
  into their layers with the background towards the front of the
  array. (My assumption is that background layers change less so it
  will make the vector more stable.) The game would return, basically,
  a list of rows of this vector and the engine would map through
  them. However, it would keep track of what the previous lists were
  and if they were eq? and in the same order, then they would not be
  set! to decrease memory traffic.
  
  I would assume that most translations, scaling, or rotations are not
  stacked, so it is safe to compose them on the CPU.
  
  -- Texture Atlas ---
  
  Additionally, I would have a single texture for all sprites in the
  game that was always available. This is called a [[https://en.wikipedia.org/wiki/Texture_atlas][Texture atlas]]. My
  idea is to write a library that scans the directory Get Bonus is in
  for all PNGs and stitches them together in a lossless way, doing
  something basic for limiting the area, with the opportunity for
  optimization later. This library would run at the start of every
  startup and find the list of files and their checksums and see if
  the cached PNG is still up to date. Similarly, this same program
  would create PNGs for fonts.
  
  I'm imaging an interface like
  
  texture-coords : path -> coordinates
  
  where the path would be relative to the Get Bonus directory and then
  the coordinates would be in the atlas that was constructed.
  
  I'd write a tool that would rip sprite sheets apart into their
  pieces.
  
  -- Notes --
  
  I've decided to go with Cg rather than GLSL directly, because of its
  separate compiler, seems to have good optimization technology, etc.
  
  Most of Nvidia's materials seem to be very good (particularly the
  manuals and examples that come with the toolkit.) [[http://filthypants.blogspot.com/2011/06/cg-shader-tutorial-for-emulators.html][Here's another]]
  source for tutorials.
  
  My current development machine is limited to OpenGL 3.2, which is
  relevant to developing with Cg. I've written a basic FFI for Cg with
  just what I need. It would be nice if there were spec files like
  RacketGL uses for OpenGL.
  
  -- Problems --
  
  First, my idea for the layout will be complicates because
  glVertexAttribPointer function can only give vertexes with 1 through
  4 elements, not this many. I might able to do it as one big thing
  anyways, by using strides and multiple attributes. (I could even do
  a different attribute for each piece.)
  
  Second, I don't totally understand the capabilities of geometry
  shaders. Essentially what I'm doing is telling OpenGL that there is
  only 1 "vertex" but then I'm expanding it into 6 by the geometry
  shader. (In the call to glDrawArray, will I put in the number of
  objects, or the number of objects times 6? Probably just the
  number?) [[http://www.opengl.org/wiki/Tutorial4:_Using_Indices_and_Geometry_Shaders_(C_/SDL)][This tutorial]] might be a good place to start. (Also, there
  are a few examples in the Nvidia CG toolkit.)
  
  Third, my initial attempts at following [[http://openglbook.com/the-book/chapter-2-vertices-and-shapes/][this tutorial]] to get things
  up in running (exp/pipe.rkt) has failed with my three rectangle
  example. First, rectangles don't show up at all. Instead, a triangle
  does. There's also a problem that only one triangle does---the front
  most one. Second, they aren't appearing in the place that I expect
  them to. I think [[http://www.opengl.org/wiki/FAQ#How_to_render_in_pixel_space][this FAQ question]] is a piece of the answer. I think
  I should start from scratch and adapt his example directly (to
  compare the drawings, for example) and go from there. ([[http://www.songho.ca/opengl/gl_vertexarray.html][This is
  another tutorial]] that may be useful.)
  
  I'm not totally certain about what the right thing to do with the
  blending between alpha, the color, and the texture color. [[http://www.opengl.org/discussion_boards/showthread.php/166520-Alpha-blending-with-Cg-shaders][Here's a
  thread]] that might have information. I also think I need to use
  (glShadeModel GL_FLAT) so that the color isn't interpolated.
  
  This is a very frustrating thing to be doing. I feel like a 142
  student.
  
  -- Useful paths --
  
  CG documentation --- /usr/share/doc/nvidia-cg-toolkit
  CG examples --- /usr/lib/nvidia-cg-toolkit/examples/OpenGL
  
  I had to install nvidia-cg-toolkit from Nvidia directly
  (Cg-3.1_April2012_x86_64.deb) because the Ubuntu one was broken.

  -- Further investigation --

  I transliterated the code from the tutorial into Racket precisely,
  including using GLUT and everything. However, it is black. I
  originally assumed this was because of GLEW, but when I disable GLEW
  in the C code, it works, but not in my code. Mysterious.

  I used 'apitrace' to determine that the OpenGL calls the two
  programs were making were literally IDENTICAL. Still, they display
  differently. My current guess is that the vertex arrays are being
  populated differently.

  After doing some tracing on the C side, I see that the bytes in my
  vertex arrays are different than the ones on the C side. Yet, I'm
  using f32vectors, which are supposed to be _float arrays. Weird.

  ARRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHH

  I mixed up the sign on a vector coordinate. The byte difference was
  just an error in printing on the C side.

  Alright, now that I have a working program, I have to go back to
  being in racket/gui or accept my new GLUT overlord. Or maybe GLFW?

  --- Progress 09/01 ---

  I've switched away from GLUT from the tutorial and switched to using
  Cg (seems like a good idea in some ways, performance and
  expressiveness, but a bad in others (less documentation it seems.))

  I've started to work on my custom shader. I've got it generating a
  quad from a single point (with six vertices).

  My next task is to work with textures. Right now I have the
  information being passed along, but I need to have three things:
  flat color quads, flat textured quads, and textured quads with a
  color blended on top. I think I will test with the Pac-Man sprite
  sheet. I think I need those examples before I can really try to
  write the code.

  --- Progress 09/02 ---

  Today I switched back to GLSL after reading about some problems
  with Cg and failing to get triangle strips to work. I find it
  really weird and annoying to write three files though, where the
  names of identifiers have to be the same. It's strange. But after I
  did the transition, then I was able to get the triangle strip
  working, so now I'm just generating 4 vertices, which is nice. Next
  up is texturing, which I've done a bit of.

  --- Progress 09/03 ---

  Basic textures are done. A few more things to do though. Changed the
  texture coordinate representation. Got indexed textures to work, but
  there's the annoying magic number length in the vertex shader. And
  I don't like the way I did it, but eh. What can you do? Just did
  rotation and scaling on the sprite level. Dramatically increased
  number of sprites to benchmark. 500 @ 60 FPS with just a transfer
  of the entire transform array. I tried to optimize by caching
  values and moving things into the vertex shader, but it did
  nothing. I wonder if geometry shaders are slow? I'm also interested
  to find out if rendering at the lower resolution would be better. I
  think I shouldn't worry about performance until after I apply it to
  the games.

  I tried to remove the Geometry Shader to improve performance. The
  first idea was to use Instanced drawing and draw 4 instances for
  each sprite (one for each corner); unfortunately, instancing is for
  meshes, not for vertices, so I couldn't use the instance id to
  identify the corner and assemble them together. So that failed.

  Next, I tried to generate 4 vertices per sprite on the CPU, but
  with all the exact same positions and then a uniform that contained
  which corner the vertex corresponded to. The first problem with
  this was that TRIANGLE_STRIP tries to connect every single sprite
  together, which is wrong. So, I changed to use glMultiDrawArrays
  with big s32vectors to identify the start of each strip. This was
  miserably slow.

  My next idea (not yet implemented) is to use glDrawElements where
  the indexes are always 0...LastSprite and the indexes are just the
  center positions and I still use a uniform to identify the
  corner. And I would use glPrimitiveRestartIndex to restart the strip
  up again.

  --- Progress 09/07 ---

  I implemented the glDrawElements with glPrimitiveRestartIndex and
  got 3 FPS with 1024 sprites. After going to a triangle-based
  rendering (so, six vertices per sprite), I was able to get 15 FPS
  with 1024 sprites (on my full laptop screen). 512 sprites is only
  20 or 30 FPS (slower than the geometry-shader based version.)

  When I added rotation, the performance didn't change. But when I
  added scaling in the shader it INCREASED! I can reliably do 1024
  sprites @ 30 FPS and 512 sprites @ over 60 FPS.

  Doing the corner calculation of hw/hh slowed it down to 30 FPS. So I
  reverted it. Same with a corner calculation of the tex coordinates,
  which means the index is pointless. I've now removed some of the
  extra stuff that supported all these experiments (the corner vertex
  array and the texture atlas index uniform. Didn't seem to have any
  effect on performance, but memory usage is down.) Now the shader is
  pretty dirt simple.

  After all this, I went back and checked out what the situation was
  with the geometry shader version that did everything on the
  card... and it gets the exact same performance. Argh! And it uses
  less memory to upload the scene!

  I think it is time to just implement this for the games and see
  what happens.

  TODO Investigate culling and/or depth testing [maybe I am losing
  efficiency by drawing over things that are already there and if I
  would not then it would be faster. However, there's a disadvantage
  here because it means that certain kinds of transparency won't
  work. But, this might not be a big deal because IIRC the SNES
  didn't have transparency either.] (painter's algorithm)

  TODO Get object width/height from sprite pixel width/height and
  just use scaling

  TODO Do texture/color blending

  TODO Optimize -- Removing the geometry shader didn't seem to
  help. But would it be wise to try an external glsl optimizer like:
  https://github.com/aras-p/glsl-optimizer

  TODO Read about for optimizing the streaming of data to the GPU:
  http://www.opengl.org/wiki/Vertex_Specification_Best_Practices#Dynamic_VBO

  TODO Combine into a single vector with strides

  TODO Consider using only integers so they always align with pixels

  TODO Deal with the model view projection
* TODO Don't use fullscreen's margin hack to get 16:9 instead just render to texture and then put on the screen centered
  Maybe even render to 720p because on my 1080p desktop machine the
  CRT emulation drops to 30fps, but I normally get 60fps on my
  1440x900 laptop display
* TODO GLFW - Wait for getting the string identifiers of joysticks
* TODO GLFW - Wait for consistent joystick state intra-frame
  So glfwPollEvents calls pollJoystickEvents and Win32 caches
* TODO Investigate and potentially using DDS for textures
  https://en.wikipedia.org/wiki/DirectDraw_Surface
* TODO Resource manager
  A DSL for defining resources...

  - All
    + Source URL
    + Copyright holder
    + Title
  - Music
    + Category
    + Conversion to Ogg
  - Image
    + Sprite layout (w/ names)
    + Conversion to texture atlas
  - Fonts
    + Conversion to texture atlas

  This would run beforehand, create some files/directory structure,
  and then drop and runtime information file so texture coords could
  be looked up.
* TODO Master Grafx2
  https://code.google.com/p/grafx2/
* TODO The Get Bonus rendering system should have built-in support for TATE games
  Virtual, Rotate Left, and Rotate Right
* TODO Try to get OpenGL to do collision detection for me
  http://kometbomb.net/2008/07/23/collision-detection-with-occlusion-queries-redux/
* TODO See if I can record a video directly
  http://revel.sourceforge.net/docs/html/revel_8h.html#a30
* TODO Make XML shader reading more robust
  In case there is just a fragment, vertex, etc (see bsnes examples)
* TODO Allow multi-pass shaders (such as CRT halation)
  See libretro or retroarch

  And maybe use Cg rather than GLSL
* TODO Make fixed-size fonts better
* TODO Use SNES sprites for Ms. Pac-Man in maze
* TODO tennis - balls can bounce infinitely off wall and get stuck
* TODO Make it so gl:Color doesn't have an alpha arg
  Because by using Z buffer for layers, translucent pixels don't work
  across layers... so maybe it is better to just disallow it?
* TODO Change FPS counter to count frame time instead
* TODO OS suppress updates
  Make a critical region system call that gives a process sole access
  to the system... leaving the other processes stalled with their last
  writes persisting from frame to frame
  
  This might be a good way to implement "friction" or "bullet time" as
  well as other effects, like menus.
  
  Just an idea. Might be a bad idea?
* TODO Make maze harder over time: faster, more ghosts, squares = score multiplier
* TODO tennis - shake the screen on bounce, gas pedal on paddle for speed, decreasing increasing rate of ball speed growth, add blocks like arkanoid?
* TODO tennis - score based on total number of balls in play
* TODO Change gl model to be memoized
* TODO Make games return score information to dashboard for it to manager
  (Version, Level, Numeric Score) from game

  (Game, Date, Version, Level, Numeric Score) from dashboard

  Store (cached) locally and online

  Store a cached global ranking
* TODO Make games return replays (and allow them to accept replays)
  Replay = (random seed, level, controller stream)
* TODO Build music libraries based on emotion (fast, race, scary, triump, etc)
* TODO Add "compare with ..." to game info
* TODO Make Anki-like SRS system in dashboard
* TODO Make icons for dashboards vs text
  Or mimic the Wii interface
* TODO Make games in dashboard have capabilities
  1P, 2P Round-robin, 2P VS, 2P Co-op, etc
* TODO Make play modes in dashboard
  Single, King-of-the-Hill (play levels that your score has been
  beaten on), Training (improve your score, SRS style), Round-Robin
  (play all games)

  Have it so you can highlight games to be played that way
* TODO Death scream like Ziggurat (in dashboard?)
  Or other stingers, but worry about being too annoying and not
  instant restarting
* TODO Find a unified common score display
  Should I display all points: this session / this game / all games?
* TODO Return achievements (to dashboard)
* TODO Make the 'Home' button in games bring up a dashboard menu (to quit the game, give a ranking, etc)
* TODO Make audio loading lazy (or other things that are slow on boot)
* TODO Read about and implement juiciness
  http://indiegames.com/2012/05/juice_it_or_lose_it_-_a_talk_b.html
  
  https://github.com/grapefrukt/juicy-breakout
* TODO Tennis - ugly score display
* TODO Tennis - revisit use of paddle bounce
* TODO Make RPS more JRPG-like
* TODO Convert things to typed racket as I go
* TODO Write a generic Godel-encoding library
* TODO Figure out a way to do localization well
* TODO Make more games
* TODO Make something for Racket/emacs to find out what deps aren't needed
* TODO Experiment with located events (in a 2D mesh) rather than flat events
* TODO Make OS use futures for parallelism
  First experiment, 2012/07/01 failed... got a slower frame rate. I
  think the key is to make it just a future during the time that GL is
  rendering.
* TODO 2D Lighting
  https://www.youtube.com/watch?v=fsbECSpwtig
* TODO Add challenges/achievements/training to NES/SNES games
  Hook up with an emulator core to drop into a game with save states
  and then monitor its execution for score, etc

  Can you beat this Mega Man stage with one life?

  How fast can you do X in this game?

  Wrap this in a package that switches from game to game like I
  want... it may be perfection

* TODO Implement Boxing iPhone game
  Like Punch-Out!!!
  
  Five "buttons": punch left/right, dodge left/right, block. The
  upper quadrants for punching, the bottom for dodging, and the
  middle for blocking.
  
  Randomly generate winning sequences of input, then from them
  determine what the bad guy does... for example if to win you dodge
  left, then he should punch right.
  
  After going through this sequence, it just repeats.
  
  Manually design 10 or so cues that indicate an upcoming action
  (like twitching eye brows, shaking, hand/leg shuffle, etc)
  
  Aim for completing a match in 1 to 2 minutes
  
  Shake the phone to get up
* TODO Winners Don't Do Drugs and other intro screens
